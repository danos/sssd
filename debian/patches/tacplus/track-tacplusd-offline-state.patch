--- a/src/providers/backend.h
+++ b/src/providers/backend.h
@@ -124,6 +124,7 @@
 bool be_is_offline(struct be_ctx *ctx);
 void be_mark_offline(struct be_ctx *ctx);
 void be_mark_dom_offline(struct sss_domain_info *dom, struct be_ctx *ctx);
+void be_mark_online_iff_offline(struct be_ctx *ctx);
 
 int be_add_reconnect_cb(TALLOC_CTX *mem_ctx,
                         struct be_ctx *ctx,
--- a/src/providers/data_provider_be.c
+++ b/src/providers/data_provider_be.c
@@ -237,6 +237,12 @@
     be_run_online_cb(ctx);
 }
 
+void be_mark_online_iff_offline(struct be_ctx *ctx)
+{
+    if (be_is_offline(ctx))
+        be_reset_offline(ctx);
+}
+
 static void be_check_online_done(struct tevent_req *req);
 
 static errno_t be_check_online_request(struct be_ctx *be_ctx)
--- a/src/providers/tacplus/tacplus_common.c
+++ b/src/providers/tacplus/tacplus_common.c
@@ -59,31 +59,298 @@
     return ret;
 }
 
-DBusConnection *tacplus_connect_daemon(struct tacplus_ctx *ctx)
+static DBusMessage *dbus_property_get(DBusConnection *conn,
+                                      const char *destination,
+                                      const char *path,
+                                      const char *interface,
+                                      const char *property,
+                                      DBusMessageIter *ret)
 {
-    DBusConnection *dconn;
     DBusError derr;
+    DBusMessage *dmsg, *dmsg_reply;
+    DBusMessageIter iter;
+
+    dmsg = dbus_message_new_method_call(
+                destination, path, DBUS_INTERFACE_PROPERTIES, "Get");
+    if(dmsg == NULL) {
+        DEBUG(SSSDBG_OP_FAILURE, "Failed to create Get(%s) method call\n", property);
+        return NULL;
+    }
+
+    dbus_message_iter_init_append(dmsg, &iter);
+    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &interface);
+    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &property);
 
     dbus_error_init(&derr);
 
-    dconn = dbus_bus_get(DBUS_BUS_SYSTEM, &derr);
+    dmsg_reply = dbus_connection_send_with_reply_and_block(
+                    conn, dmsg, TACPLUS_DAEMON_TIMEOUT_MS, &derr);
+    if((tacplus_validate_reply_msg(&derr)) < 0) {
+        DEBUG(SSSDBG_OP_FAILURE, "Failed to get online status of TACACS+ provider\n");
+        goto finish;
+    }
+
+    if (! dbus_message_iter_init(dmsg_reply, &iter)) {
+        dbus_message_unref(dmsg_reply);
+        dmsg_reply = NULL;
+        goto finish;
+    }
+
+    dbus_message_iter_recurse(&iter, ret);
+
+finish:
+    dbus_message_unref(dmsg);
+    /* Caller is required to unref dmsg_reply */
+    return dmsg_reply;
+}
+
+int tacplus_get_offline(struct tacplus_ctx *ctx)
+{
+    DBusConnection *conn;
+    DBusMessage *reply;
+    DBusMessageIter iter;
+    DBusBasicValue offline;
+
+    DEBUG(SSSDBG_TRACE_FUNC, "Getting offline status of "TACPLUS_DAEMON"\n");
+
+    conn = tacplus_connect_daemon(ctx);
+    if (! conn)
+        return -1;
+
+    reply = dbus_property_get(conn, TACPLUS_DAEMON,
+                              TACPLUS_DAEMON_PATH, TACPLUS_DAEMON_IFACE,
+                              TACPLUS_DAEMON_PROP_OFFLINE, &iter);
+    if (! reply)
+        return -1;
+
+    if (dbus_message_iter_get_arg_type(&iter) == DBUS_TYPE_BOOLEAN) {
+        dbus_message_iter_get_basic(&iter, &offline);
+        dbus_message_unref(reply);
+        return offline.bool_val ? 1 : 0;
+    }
+
+    DEBUG(SSSDBG_TRACE_FUNC,
+        "Unexpected type for "TACPLUS_DAEMON" "TACPLUS_DAEMON_PROP_OFFLINE" property");
+    dbus_message_unref(reply);
+    return -1;
+}
+
+static DBusHandlerResult props_changed_handler(DBusConnection *connection,
+                                               DBusMessage *message, void *user)
+{
+    struct tacplus_ctx *ctx = user;
+    DBusMessageIter parentIter, dictIter, dictEntryIter, variantIter;
+    const char *name;
+
+    if (! dbus_message_is_signal(message, DBUS_INTERFACE_PROPERTIES, TACPLUS_DAEMON_PROP_CHG_SIG))
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+    if (! dbus_message_iter_init(message, &parentIter) ||
+            dbus_message_iter_get_arg_type(&parentIter) != DBUS_TYPE_STRING)
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+    dbus_message_iter_get_basic(&parentIter, &name);
+
+    if (strcmp(name, TACPLUS_DAEMON) || !dbus_message_iter_next(&parentIter))
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+    DEBUG(SSSDBG_TRACE_FUNC,
+          "Received "TACPLUS_DAEMON_PROP_CHG_SIG" signal from "TACPLUS_DAEMON"\n");
+
+    dbus_message_iter_recurse(&parentIter, &dictIter);
+
+    while ((dbus_message_iter_get_arg_type(&dictIter) == DBUS_TYPE_DICT_ENTRY)) {
+        dbus_message_iter_recurse(&dictIter, &dictEntryIter);
+
+        while ((dbus_message_iter_get_arg_type(&dictEntryIter)) == DBUS_TYPE_STRING) {
+            const char *key;
+            dbus_message_iter_get_basic(&dictEntryIter, &key);
+            dbus_message_iter_next(&dictEntryIter);
+            if (dbus_message_iter_get_arg_type(&dictEntryIter) != DBUS_TYPE_VARIANT)
+                continue;
+
+            if (strcmp(key, TACPLUS_DAEMON_PROP_OFFLINE) == 0) {
+                dbus_message_iter_recurse(&dictEntryIter, &variantIter);
+                if((dbus_message_iter_get_arg_type(&variantIter)) != DBUS_TYPE_BOOLEAN)
+                    continue;
+
+                DBusBasicValue offline;
+                dbus_message_iter_get_basic(&variantIter, &offline);
+                DEBUG(SSSDBG_TRACE_FUNC, TACPLUS_DAEMON" signals it has gone %s\n",
+                    offline.bool_val ? "offline" : "online");
+
+                if (offline.bool_val)
+                    be_mark_offline(ctx->be);
+                else
+                    be_mark_online_iff_offline(ctx->be);
+            }
+
+            dbus_message_iter_next(&dictEntryIter);
+        }
+        dbus_message_iter_next(&dictIter);
+    }
+
+    return DBUS_HANDLER_RESULT_HANDLED;
+}
+
+static void tacplus_reconnect_cb(struct tevent_context *,
+                                 struct tevent_timer *,
+                                 struct timeval,
+                                 void *);
+
+static int tacplus_start_reconnect_timer(struct tacplus_ctx *ctx, uint32_t secs)
+{
+    struct timeval exp = tevent_timeval_current_ofs(secs, 0);
+    if (! tevent_add_timer(ctx->be->ev, ctx->be, exp,
+                           tacplus_reconnect_cb, ctx)) {
+        DEBUG(SSSDBG_OP_FAILURE, "Failure scheduling DBus reconnect\n");
+        return -1;
+    }
+    return 0;
+}
+
+static void tacplus_reconnect_cb(struct tevent_context *ev,
+                                 struct tevent_timer *t,
+                                 struct timeval curr_time,
+                                 void *user)
+{
+    struct tacplus_ctx *ctx = user;
+
+    DEBUG(SSSDBG_TRACE_FUNC, "Attempting DBus reconnect\n");
+
+    if (ctx->sconn) {
+        sbus_disconnect(ctx->sconn);
+        /* sbus_disconnect() unref'd ctx->conn */
+        ctx->conn = NULL;
+        ctx->sconn = NULL;
+    }
+
+    if (tacplus_setup_connection(ctx) == 0) {
+        DEBUG(SSSDBG_TRACE_FUNC, "DBus reconnect succeeded\n");
+        return;
+    }
+
+    if (tacplus_start_reconnect_timer(ctx, TACPLUS_BUS_RECONNECT_START) == 0)
+        DEBUG(SSSDBG_TRACE_FUNC, "DBus reconnect failed - retry in %us\n",
+              TACPLUS_BUS_RECONNECT_START);
+
+    return;
+}
+
+void tacplus_reconnect(struct sbus_connection *sconn, int status, void *data)
+{
+    struct tacplus_ctx *ctx = data;
+
+    DEBUG(SSSDBG_TRACE_FUNC, "Scheduling DBus reconnect\n");
 
+    if (sconn != ctx->sconn) {
+        DEBUG(SSSDBG_TRACE_FUNC, "DBus reconnect attempt on stale connection\n");
+        return;
+    }
+
+    tacplus_start_reconnect_timer(ctx, TACPLUS_BUS_RECONNECT_START);
+}
+
+int tacplus_setup_connection(struct tacplus_ctx *ctx)
+{
+    DBusError derr;
+
+    /* Connection is already setup */
+    if (ctx->conn)
+        return 0;
+
+    dbus_error_init(&derr);
+    ctx->conn = dbus_bus_get_private(DBUS_BUS_SYSTEM, &derr);
     if (dbus_error_is_set(&derr)) {
         DEBUG(SSSDBG_OP_FAILURE,
-              "Failed to connect to system bus: %s",
-                          derr.message);
+              "Failed to connect to system bus: %s\n", derr.message);
         dbus_error_free(&derr);
-        return NULL;
+        ctx->conn = NULL;
+        return -1;
     }
+    dbus_connection_set_exit_on_disconnect(ctx->conn, false);
 
-    return dconn;
+    /* Add match so we receive PropertiesChanged signals from tacplusd */
+    dbus_bus_add_match(ctx->conn,
+        "type='signal',"
+        "sender='"TACPLUS_DAEMON"',"
+        "interface='"DBUS_INTERFACE_PROPERTIES"',"
+        "member='"TACPLUS_DAEMON_PROP_CHG_SIG"'",
+        &derr);
+    if (dbus_error_is_set(&derr)) {
+        DEBUG(SSSDBG_OP_FAILURE,
+              "Add "TACPLUS_DAEMON_PROP_CHG_SIG" match failure: %s\n", derr.message);
+        goto fail;
+    }
+
+    /* Add filter to handle signal receipt */
+    if (! dbus_connection_add_filter(ctx->conn, props_changed_handler, ctx, NULL)) {
+        DEBUG(SSSDBG_OP_FAILURE,
+              "dbus_connection_add_filter(props_changed_handler) fail\n");
+        goto fail;
+    }
+
+    /* Init sbus connection in order to hook into the event loop */
+    int ret = sbus_init_connection(ctx, ctx->be->ev, ctx->conn,
+                                   SBUS_CONN_TYPE_SYSBUS, NULL, NULL,
+                                   &ctx->sconn);
+    if (ret != EOK) {
+        DEBUG(SSSDBG_OP_FAILURE, "sbus_init_connection() fail: %d\n", ret);
+        goto fail;
+    }
+
+    /*
+     * Set a reconnect callback to detect errors on the connection and re-connect.
+     * A max retries value of 1 will cause our callback to be called immediately
+     * on each reconnect attempt, rather than using the "automatic" sbus_reconnect().
+     */
+    sbus_reconnect_init(ctx->sconn, 1, tacplus_reconnect, ctx);
+    DEBUG(SSSDBG_TRACE_FUNC, "DBus connection successfully setup\n");
+
+    int offline = tacplus_get_offline(ctx);
+
+    /*
+     * If we could not determine the offline status of tacplusd then
+     * leave the offline state of the provider unchanged.
+     */
+    if (offline < 0)
+        return 0;
+
+    /* Otherwise adjust the offline state of the provider */
+    DEBUG(SSSDBG_TRACE_FUNC, "tacplusd is currently %s\n", offline ? "offline" : "online");
+    if (offline)
+        be_mark_offline(ctx->be);
+    else
+        be_mark_online_iff_offline(ctx->be);
+
+    return 0;
+
+fail:
+    if (dbus_error_is_set(&derr))
+        dbus_error_free(&derr);
+
+    if (ctx->sconn) {
+        sbus_disconnect(ctx->sconn);
+        TALLOC_FREE(ctx->sconn);
+    } else {
+        dbus_connection_unref(ctx->conn);
+    }
+
+    ctx->conn = NULL;
+    return -1;
+}
+
+DBusConnection *tacplus_connect_daemon(struct tacplus_ctx *ctx)
+{
+    tacplus_setup_connection(ctx);
+    return ctx->conn;
 }
 
 int tacplus_validate_reply_msg(DBusError *derr)
 {
     if (dbus_error_is_set(derr)) {
         DEBUG(SSSDBG_OP_FAILURE,
-              "failed to receive a reply: %s",
+              "failed to receive a reply: %s\n",
                derr->message);
         dbus_error_free(derr);
         return -1;
@@ -95,11 +362,10 @@
 {
     if (dbus_error_is_set(derr)) {
         DEBUG(SSSDBG_OP_FAILURE,
-              "failed to retrieve basic type argument: %s",
+              "failed to retrieve basic type argument: %s\n",
                derr->message);
         dbus_error_free(derr);
         return -1;
     }
     return 0;
 }
-
--- a/src/providers/tacplus/tacplus_common.h
+++ b/src/providers/tacplus/tacplus_common.h
@@ -32,9 +32,15 @@
 #define TACPLUS_DAEMON_AUTHEN  "authen_send"
 #define TACPLUS_DAEMON_AUTHOR  "author_send"
 #define TACPLUS_DAEMON_ACCT    "account_send"
+
+#define TACPLUS_DAEMON_PROP_OFFLINE "offline"
+#define TACPLUS_DAEMON_PROP_CHG_SIG "PropertiesChanged"
+
 /* how long should we wait on a reply from the daemon?*/
 #define TACPLUS_DAEMON_TIMEOUT_MS 10000
 
+#define TACPLUS_BUS_RECONNECT_START 1
+
 /* authorization status codes */
 #define TAC_PLUS_AUTHOR_STATUS_PASS_ADD  0x01
 #define TAC_PLUS_AUTHOR_STATUS_PASS_REPL 0x02
@@ -62,7 +68,6 @@
 #define TAC_PLUS_ACCT_FLAG_STOP     0x04
 
 
-
 struct tacplus_options {
     struct dp_option *basic;
 };
@@ -81,6 +86,8 @@
 struct tacplus_ctx {
     struct be_ctx *be;
     struct tacplus_options *opts;
+    DBusConnection *conn;
+    struct sbus_connection *sconn;
 };
 
 /* options parser */
@@ -89,8 +96,11 @@
                      const char *conf_path,
                      struct tacplus_options **_opts);
 
-DBusConnection * tacplus_connect_daemon(struct tacplus_ctx *);
+int tacplus_setup_connection(struct tacplus_ctx *);
+DBusConnection *tacplus_connect_daemon(struct tacplus_ctx *);
 int tacplus_validate_reply_msg(DBusError *);
 int tacplus_validate_basic_reply_args(DBusError *);
 
+int tacplus_get_offline(struct tacplus_ctx *);
+
 #endif /* _TACPLUS_COMMON_H_ */
--- a/src/providers/tacplus/tacplus_id.c
+++ b/src/providers/tacplus/tacplus_id.c
@@ -231,7 +231,7 @@
 
 /* Vyatta specific bits for "vyatta-exec" service handling.
  * The vyatta-exec service handles following vendor specific
- * attributes: level=
+ * attributes: level= and secrets*
  *
  * TODO: make those configurable via SSSD so we no longer need
  * to maintain this as vyatta specific code piece.
@@ -780,6 +780,48 @@
     return EOK;
 }
 
+struct tacplus_check_online_ctx {
+    int offline;
+};
+
+static struct tevent_req *
+tacplus_check_online_handler_send(TALLOC_CTX *mem_ctx,
+                                  struct tacplus_ctx *mod_ctx,
+                                  void *data,
+                                  struct dp_req_params *params)
+{
+    struct tevent_req *req;
+    struct tacplus_check_online_ctx *ctx;
+
+    req = tevent_req_create(mem_ctx, &ctx, struct tacplus_check_online_ctx);
+    if (!req) {
+        DEBUG(SSSDBG_CRIT_FAILURE, "tevent_req_create() failure\n");
+        return NULL;
+    }
+
+    ctx->offline = tacplus_get_offline(mod_ctx);
+
+    tevent_req_done(req);
+    tevent_req_post(req, params->ev);
+    return req;
+}
+
+static errno_t
+tacplus_check_online_handler_recv(TALLOC_CTX *mem_ctx,
+                                  struct tevent_req *req,
+                                  struct dp_reply_std *data)
+{
+    struct tacplus_check_online_ctx *ctx;
+
+    ctx = tevent_req_data(req, struct tacplus_check_online_ctx);
+
+    TEVENT_REQ_RETURN_ON_ERROR(req);
+
+    dp_reply_std_set(data, ctx->offline ? DP_ERR_OFFLINE : DP_ERR_OK,
+                     ctx->offline, NULL);
+    return EOK;
+}
+
 errno_t
 sssm_tacplus_id_init(TALLOC_CTX *mem_ctx,
                      struct be_ctx *bectx,
@@ -798,5 +840,10 @@
     dp_set_method(dp_methods, DPM_ACCT_DOMAIN_HANDLER,
                   default_account_domain_send, default_account_domain_recv,
                   NULL, void, struct dp_get_acct_domain_data, struct dp_reply_std);
+
+    dp_set_method(dp_methods, DPM_CHECK_ONLINE,
+                  tacplus_check_online_handler_send,
+                  tacplus_check_online_handler_recv,
+                  ctx, struct tacplus_ctx, void, struct dp_reply_std);
     return EOK;
 }
--- a/src/providers/tacplus/tacplus_init.c
+++ b/src/providers/tacplus/tacplus_init.c
@@ -43,6 +43,8 @@
         goto done;
     }
 
+    tacplus_setup_connection(ctx);
+
     *data = ctx;
     return EOK;
 
--- a/src/monitor/monitor.c
+++ b/src/monitor/monitor.c
@@ -218,7 +218,11 @@
     for (iter = ctx->svc_list; iter; iter = iter->next) {
         /* Don't signal services, only providers */
         if (iter->provider) {
-            service_signal_reset_offline(iter);
+            if (strcasecmp(iter->provider, "tacplus") == 0)
+                DEBUG(SSSDBG_TRACE_INTERNAL, "Not signalling tacplus "
+                      "provider on network status change\n");
+            else
+                service_signal_reset_offline(iter);
         }
     }
 }
