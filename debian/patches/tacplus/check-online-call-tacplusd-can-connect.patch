--- a/src/providers/backend.h
+++ b/src/providers/backend.h
@@ -126,6 +126,8 @@
 void be_mark_dom_offline(struct sss_domain_info *dom, struct be_ctx *ctx);
 void be_mark_online_iff_offline(struct be_ctx *ctx);
 
+void check_if_online(struct be_ctx *be_ctx);
+
 int be_add_reconnect_cb(TALLOC_CTX *mem_ctx,
                         struct be_ctx *ctx,
                         be_callback_t cb,
--- a/src/providers/data_provider_be.c
+++ b/src/providers/data_provider_be.c
@@ -71,8 +71,6 @@
     return ctx->offstat.offline;
 }
 
-static void check_if_online(struct be_ctx *be_ctx);
-
 static errno_t
 try_to_go_online(TALLOC_CTX *mem_ctx,
                  struct tevent_context *ev,
@@ -319,7 +317,7 @@
     }
 }
 
-static void check_if_online(struct be_ctx *be_ctx)
+void check_if_online(struct be_ctx *be_ctx)
 {
     errno_t ret;
 
--- a/src/providers/tacplus/tacplus_common.c
+++ b/src/providers/tacplus/tacplus_common.c
@@ -59,6 +59,99 @@
     return ret;
 }
 
+static void
+tacplus_can_connect_done(DBusPendingCall *pending, void *user)
+{
+    struct tevent_req *req = user;
+    struct tacplus_can_connect_ctx *ctx;
+    DBusMessage *dmsg = NULL;
+    DBusMessageIter iter;
+    DBusBasicValue can_connect;
+    int msg_type;
+
+    ctx = tevent_req_data(req, struct tacplus_can_connect_ctx);
+    ctx->can_connect = -1;
+
+    dmsg = dbus_pending_call_steal_reply(pending);
+    if (!dmsg) {
+        DEBUG(SSSDBG_TRACE_FUNC, "Method reply callback with no message\n");
+        tevent_req_error(req, ENOENT);
+        return;
+    }
+
+    msg_type = dbus_message_get_type(dmsg);
+    switch (msg_type) {
+    case DBUS_MESSAGE_TYPE_METHOD_RETURN:
+        if (! dbus_message_iter_init(dmsg, &iter))
+            break;
+
+        if (dbus_message_iter_get_arg_type(&iter) == DBUS_TYPE_BOOLEAN) {
+            dbus_message_iter_get_basic(&iter, &can_connect);
+            ctx->can_connect = can_connect.bool_val ? 1 : 0;
+        }
+        else {
+            DEBUG(SSSDBG_TRACE_FUNC,
+                  "Unexpected return type for "TACPLUS_DAEMON_CAN_CONNECT"()\n");
+        }
+        break;
+    case DBUS_MESSAGE_TYPE_ERROR:
+        DEBUG(SSSDBG_TRACE_FUNC,
+              TACPLUS_DAEMON_CAN_CONNECT"() error: %s\n",
+              dbus_message_get_error_name(dmsg));
+        break;
+    default:
+        break;
+    }
+
+    dbus_message_unref(dmsg);
+    tevent_req_done(req);
+}
+
+struct tevent_req *
+tacplus_can_connect(TALLOC_CTX *mem_ctx, struct tacplus_ctx *mod_ctx)
+{
+    struct tevent_req *req;
+    struct tacplus_can_connect_ctx *ctx;
+    DBusMessage *dmsg;
+    int ret;
+
+    req = tevent_req_create(mem_ctx, &ctx, struct tacplus_can_connect_ctx);
+    if (!req) {
+        DEBUG(SSSDBG_CRIT_FAILURE, "tevent_req_create() failure\n");
+        return NULL;
+    }
+
+    tacplus_connect_daemon(mod_ctx);
+    if (!mod_ctx->sconn) {
+        DEBUG(SSSDBG_TRACE_FUNC, "Failed to connect to tacplus daemon\n");
+        tevent_req_error(req, EIO);
+        return req;
+    }
+
+    dmsg = dbus_message_new_method_call(TACPLUS_DAEMON,
+                                        TACPLUS_DAEMON_PATH,
+                                        TACPLUS_DAEMON_IFACE,
+                                        TACPLUS_DAEMON_CAN_CONNECT);
+    if(!dmsg) {
+        DEBUG(SSSDBG_OP_FAILURE,
+              "Failed to create "TACPLUS_DAEMON_CAN_CONNECT"() method call\n");
+        tevent_req_error(req, ENOMEM);
+        return req;
+    }
+
+    ret = sbus_conn_send(mod_ctx->sconn, dmsg, TACPLUS_DAEMON_TIMEOUT_MS,
+                         tacplus_can_connect_done, req, NULL);
+    dbus_message_unref(dmsg);
+    if (ret) {
+        DEBUG(SSSDBG_OP_FAILURE,
+              "Failed to dispatch "TACPLUS_DAEMON_CAN_CONNECT"() "
+              "method call: %d (%s)\n", ret, sss_strerror(ret));
+        tevent_req_error(req, ret);
+    }
+
+    return req;
+}
+
 static DBusMessage *dbus_property_get(DBusConnection *conn,
                                       const char *destination,
                                       const char *path,
@@ -182,7 +275,7 @@
                 if (offline.bool_val)
                     be_mark_offline(ctx->be);
                 else
-                    be_mark_online_iff_offline(ctx->be);
+                    check_if_online(ctx->be);
             }
 
             dbus_message_iter_next(&dictEntryIter);
@@ -321,7 +414,7 @@
     if (offline)
         be_mark_offline(ctx->be);
     else
-        be_mark_online_iff_offline(ctx->be);
+        check_if_online(ctx->be);
 
     return 0;
 
--- a/src/providers/tacplus/tacplus_common.h
+++ b/src/providers/tacplus/tacplus_common.h
@@ -26,12 +26,13 @@
 #include <sys/types.h>
 #include "providers/backend.h"
 
-#define TACPLUS_DAEMON         "net.vyatta.tacplus"
-#define TACPLUS_DAEMON_PATH    "/net/vyatta/tacplus"
-#define TACPLUS_DAEMON_IFACE   "net.vyatta.tacplus"
-#define TACPLUS_DAEMON_AUTHEN  "authen_send"
-#define TACPLUS_DAEMON_AUTHOR  "author_send"
-#define TACPLUS_DAEMON_ACCT    "account_send"
+#define TACPLUS_DAEMON              "net.vyatta.tacplus"
+#define TACPLUS_DAEMON_PATH         "/net/vyatta/tacplus"
+#define TACPLUS_DAEMON_IFACE        "net.vyatta.tacplus"
+#define TACPLUS_DAEMON_AUTHEN       "authen_send"
+#define TACPLUS_DAEMON_AUTHOR       "author_send"
+#define TACPLUS_DAEMON_ACCT         "account_send"
+#define TACPLUS_DAEMON_CAN_CONNECT  "can_connect"
 
 #define TACPLUS_DAEMON_PROP_OFFLINE "offline"
 #define TACPLUS_DAEMON_PROP_CHG_SIG "PropertiesChanged"
@@ -103,4 +104,11 @@
 
 int tacplus_get_offline(struct tacplus_ctx *);
 
+struct tacplus_can_connect_ctx {
+    int can_connect;
+};
+
+struct tevent_req *tacplus_can_connect(TALLOC_CTX *mem_ctx,
+                                       struct tacplus_ctx *ctx);
+
 #endif /* _TACPLUS_COMMON_H_ */
--- a/src/providers/tacplus/tacplus_id.c
+++ b/src/providers/tacplus/tacplus_id.c
@@ -648,14 +648,44 @@
     return ret;
 }
 
-static bool handle_request_for_user(const struct dp_id_data *data,
-                                    const struct sss_domain_info *dom,
-                                    const struct tacplus_id_handler_ctx *ctx)
+static void
+tacplus_id_handler_can_connect_done(struct tevent_req *subreq)
+{
+    struct tevent_req *req;
+    struct tacplus_can_connect_ctx *cc_ctx;
+    struct tacplus_id_handler_ctx *id_ctx;
+
+    req = tevent_req_callback_data(subreq, struct tevent_req);
+    cc_ctx = tevent_req_data(subreq, struct tacplus_can_connect_ctx);
+    id_ctx = tevent_req_data(req, struct tacplus_id_handler_ctx);
+
+    if (cc_ctx->can_connect <= 0) {
+        be_mark_offline(id_ctx->ctx->be);
+        dp_reply_std_set(&id_ctx->reply, DP_ERR_OFFLINE, ENXIO, "Going offline");
+    }
+    else {
+        dp_reply_std_set(&id_ctx->reply, DP_ERR_OK, EOK, NULL);
+    }
+
+    talloc_zfree(subreq);
+    tevent_req_done(req);
+}
+
+/*
+ * Determines how to handle the request for a given user, indicated by
+ * return value:
+ *     1 handle request normally
+ *    -1 ignore the request (respond EOK)
+ *     0 perform a connection check only (no TACACS+ transaction)
+ */
+static int handle_request_for_user(const struct dp_id_data *data,
+                                   const struct sss_domain_info *dom,
+                                   const struct tacplus_id_handler_ctx *ctx)
 {
     struct passwd *pw;
 
     if (data->entry_type != BE_REQ_INITGROUPS)
-        return true;
+        return 1;
 
     /*
      * We are likely to receive an initgroups request for local users
@@ -669,12 +699,30 @@
      */
     pw = getpwnam(ctx->username);
     if (pw && OUT_OF_ID_RANGE(pw->pw_uid, dom->id_min, dom->id_max)) {
-        DEBUG(SSSDBG_TRACE_FUNC, "User %s (UID %u) already exists outside this "
-              "domain - ignoring initgroups request.\n", ctx->username, pw->pw_uid);
-        return false;
+
+        /*
+         * If the user exists and is a system user, we ignore it.
+         */
+        if (pw->pw_uid < 1000) {
+            DEBUG(SSSDBG_TRACE_FUNC, "User %s (UID %u) already exists "
+                  "outside this domain - ignoring initgroups request.\n",
+                  ctx->username, pw->pw_uid);
+            return -1;
+        }
+
+        /*
+         * Otherwise we perform a "connection check" rather than a TACACS+
+         * transaction; if the check fails then we take ourselves offline.
+         * This allows local user fallback to work when TACACS+ is unavailable
+         * simply by attempting to log in as a local user, but avoids performing
+         * a TACACS+ transaction which will likely fail.
+         */
+        DEBUG(SSSDBG_TRACE_FUNC, "Doing TACACS+ connection check for non-domain "
+              "user %s (UID %u)\n", ctx->username, pw->pw_uid);
+        return 0;
     }
 
-    return true;
+    return 1;
 }
 
 static struct tevent_req *
@@ -685,6 +733,7 @@
 {
     struct tevent_req *req;
     struct tacplus_id_handler_ctx *ctx;
+    struct tevent_req *can_connect_req;
     uid_t uid;
     int ret;
     char *endptr;
@@ -713,10 +762,23 @@
             if (ret)
                 break;
 
-            if (handle_request_for_user(data, params->domain, ctx))
-                ret = get_pw_name(req, ctx, params->domain);
-            else
+            ret = handle_request_for_user(data, params->domain, ctx);
+            if (ret < 0)
                 ret = EOK;
+            else if (ret)
+                ret = get_pw_name(req, ctx, params->domain);
+            else {
+                can_connect_req = tacplus_can_connect(req, mod_ctx);
+                if (!can_connect_req) {
+                    tevent_req_error(req, ENOMEM);
+                    goto post;
+                }
+
+                tevent_req_set_callback(
+                    can_connect_req, tacplus_id_handler_can_connect_done, req);
+
+                return req;
+            }
 
             if (ret) {
                 if (ret == ENXIO || ret == EIO || ret == EFAULT) {
@@ -759,8 +821,10 @@
     else
         dp_reply_std_set(&ctx->reply, DP_ERR_OK, EOK, NULL);
 
+    /* no deferred operations in progress */
 done:
     tevent_req_done(req);
+post:
     tevent_req_post(req, params->ev);
     return req;
 }
@@ -780,9 +844,26 @@
     return EOK;
 }
 
-struct tacplus_check_online_ctx {
-    int offline;
-};
+static void
+tacplus_check_online_done(struct tevent_req *subreq)
+{
+    struct tevent_req *req;
+    struct tacplus_can_connect_ctx *ctx;
+    struct dp_reply_std *reply;
+
+    req = tevent_req_callback_data(subreq, struct tevent_req);
+    ctx = tevent_req_data(subreq, struct tacplus_can_connect_ctx);
+    reply = tevent_req_data(req, struct dp_reply_std);
+
+    if (ctx->can_connect <= 0)
+        dp_reply_std_set(reply, DP_ERR_OFFLINE, ENXIO,
+                         "TACACS+ server connection check failed");
+    else
+        dp_reply_std_set(reply, DP_ERR_OK, EOK, NULL);
+
+    talloc_zfree(subreq);
+    tevent_req_done(req);
+}
 
 static struct tevent_req *
 tacplus_check_online_handler_send(TALLOC_CTX *mem_ctx,
@@ -790,19 +871,23 @@
                                   void *data,
                                   struct dp_req_params *params)
 {
-    struct tevent_req *req;
-    struct tacplus_check_online_ctx *ctx;
+    struct tevent_req *req, *subreq;
+    struct dp_reply_std *reply;
 
-    req = tevent_req_create(mem_ctx, &ctx, struct tacplus_check_online_ctx);
+    req = tevent_req_create(mem_ctx, &reply, struct dp_reply_std);
     if (!req) {
         DEBUG(SSSDBG_CRIT_FAILURE, "tevent_req_create() failure\n");
         return NULL;
     }
 
-    ctx->offline = tacplus_get_offline(mod_ctx);
-
-    tevent_req_done(req);
-    tevent_req_post(req, params->ev);
+    subreq = tacplus_can_connect(req, mod_ctx);
+    if (!subreq) {
+        tevent_req_error(req, ENOMEM);
+        tevent_req_post(req, params->ev);
+    }
+    else {
+        tevent_req_set_callback(subreq, tacplus_check_online_done, req);
+    }
     return req;
 }
 
@@ -811,14 +896,9 @@
                                   struct tevent_req *req,
                                   struct dp_reply_std *data)
 {
-    struct tacplus_check_online_ctx *ctx;
-
-    ctx = tevent_req_data(req, struct tacplus_check_online_ctx);
-
     TEVENT_REQ_RETURN_ON_ERROR(req);
 
-    dp_reply_std_set(data, ctx->offline ? DP_ERR_OFFLINE : DP_ERR_OK,
-                     ctx->offline, NULL);
+    *data = *(tevent_req_data(req, struct dp_reply_std));
     return EOK;
 }
 
